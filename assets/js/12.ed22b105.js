(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{330:function(t,a,e){"use strict";e.r(a);var s=e(3),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"git分支本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git分支本质"}},[t._v("#")]),t._v(" git分支本质")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("分支本质是一个提交对象,所有的分支都会有机会被HEAD所引用(HEAD一个时刻只会指向一个分支)\n当我们有新的提交的时候 HEAD会携带当前持有的分支往前移动\n")])])]),a("h3",{attrs:{id:"git分支命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git分支命令"}},[t._v("#")]),t._v(" git分支命令")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("创建分支            : git branch branchname\n切换分支           : git checkout  branchname\n创建&切换分支     : git checkout -b branchname\n版本穿梭(时光机) :  git branch branchname commitHash  \n普通删除分支      : git  branch -d branchname\n强制删除分支      : git  branch -D branchname\n合并分支         : git merge branchname\n    快进合并 --\x3e 不会产生冲突\n    典型合并 --\x3e 有机会产生冲突\n    解决冲突 --\x3e 打开冲突的文件 进行修改 add commit \n  \n\n查看分支列表 : git branch\n查看合并到当前分支的分支列表: git branch --merged\n    一旦出现在这个列表中 就应该删除\n查看没有合并到当前分支的分支列表: git branch --no-merged\n    一旦出现在这个列表中 就应该观察一下是否需要合并\n")])])]),a("h3",{attrs:{id:"git分支的注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git分支的注意点"}},[t._v("#")]),t._v(" git分支的注意点")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("在切换的时候 一定要保证当前分支是干净的!!!\n    允许切换分支: \n        分支上所有的内容处于 已提交状态    \n        (避免)分支上的内容是初始化创建 处于未跟踪状态\n        (避免)分支上的内容是初始化创建 第一次处于已暂存状态\n    不允许切分支:\n         分支上所有的内容处于 已修改状态  或 第二次以后的已暂存状态  \n         \n在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作存储起来\n    git stash : 会将当前分支上的工作推到一个栈中\n    分支切换  进行其他工作 完成其他工作后 切回原分支\n    git stash apply : 将栈顶的工作内容还原 但不让任何内容出栈 \n    git stash drop  : 取出栈顶的工作内容后 就应该将其删除(出栈)\n    git stash pop   :      git stash apply +  git stash drop \n    git stash list : 查看存储\n")])])]),a("h3",{attrs:{id:"后悔药"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后悔药"}},[t._v("#")]),t._v(" 后悔药")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("撤销工作目录的修改   :  git checkout -- filename\n撤销暂存区的修改     :  git reset HEAD  filename\n撤销提交             :  git commit --amend\n")])])]),a("h3",{attrs:{id:"reset三部曲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset三部曲"}},[t._v("#")]),t._v(" reset三部曲")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("git reset --soft commithash    ---\x3e 用commithash的内容重置HEAD内容\ngit reset [--mixed] commithash ---\x3e 用commithash的内容重置HEAD内容 重置暂存区\ngit reset --hard commithash    ---\x3e 用commithash的内容重置HEAD内容 重置暂存区 重置工作目录\n")])])]),a("h3",{attrs:{id:"路径reset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路径reset"}},[t._v("#")]),t._v(" 路径reset")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("所有的路径reset都要省略第一步!!!\n    第一步是重置HEAD内容  我们知道HEAD本质指向一个分支 分支的本质是一个提交对象 \n    提交对象 指向一个树对象 树对象又很有可能指向多个git对象 一个git对象代表一个文件!!!\n    HEAD可以代表一系列文件的状态!!!!\ngit reset [--mixed] commithash filename  \n     用commithash中filename的内容重置暂存区\n")])])]),a("h3",{attrs:{id:"checkout深入理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checkout深入理解"}},[t._v("#")]),t._v(" checkout深入理解")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("git   checkout brancname  跟   git reset --hard commithash特别像\n    共同点\n        都需要重置 HEAD   暂存区   工作目录\n    区别\n         checkout对工作目录是安全的    reset --hard是强制覆盖\n         checkout动HEAD时不会带着分支走而是切换分支\n         reset --hard时是带着分支走\n         \ncheckout + 路径\n      git checkout commithash  filename   \n           重置暂存区\n           重置工作目录\n      git checkout -- filename  \n          重置工作目录  \n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);